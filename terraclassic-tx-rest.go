package terraclassicda

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	clientx "github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/tx"
	"github.com/cosmos/cosmos-sdk/codec"
	sdktypes "github.com/cosmos/cosmos-sdk/types"

	"github.com/cosmos/cosmos-sdk/types/tx/signing"

	xauthsigning "github.com/cosmos/cosmos-sdk/x/auth/signing"
	authtx "github.com/cosmos/cosmos-sdk/x/auth/tx"

	wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"
	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
)
type TxResponse struct {
    Height    string          `json:"height"`    // The block height where the transaction was included
    TxHash    string         `json:"txhash"`    // The transaction hash
    Codespace string         `json:"codespace"` // Namespace for the error code
    Code      uint32         `json:"code"`      // Response code (0 for success)
    Data      string         `json:"data"`      // Result data (if any)
    RawLog    string         `json:"raw_log"`   // Raw log message
    Logs      ABCIMessageLogs `json:"logs"`      // Logs from the transaction execution
    Info      string         `json:"info"`      // Additional information
    GasWanted string          `json:"gas_wanted"`// Gas requested
    GasUsed   string          `json:"gas_used"`  // Gas used
    Tx        Tx             `json:"tx"`        // The transaction itself
    Timestamp string         `json:"timestamp"` // Timestamp of the block
    Events    []Event        `json:"events"`    // Events emitted during the transaction execution
}
type ResponseTerra struct {
	TxResponse TxResponse `json:"tx_response"`
}
// ABCIMessageLogs represents a slice of ABCIMessageLog.
type ABCIMessageLogs []ABCIMessageLog

// ABCIMessageLog defines a structure for logging messages from an ABCI application.
type ABCIMessageLog struct {
    MsgIndex uint32         `json:"msg_index"` // Message index in the transaction
    Log      string         `json:"log"`       // Log message
    Events   StringEvents   `json:"events"`    // Events generated by the message
}

// StringEvents represents a slice of StringEvent.
type StringEvents []StringEvent

// StringEvent defines a structure for string events.
type StringEvent struct {
    Type       string            `json:"type"`       // Type of the event
    Attributes []EventAttribute  `json:"attributes"` // Attributes of the event
}

// EventAttribute defines a structure for event attributes.
type EventAttribute struct {
    Key   string `json:"key"`   // Attribute key
    Value string `json:"value"` // Attribute value
}

// Tx defines a structure for a Cosmos SDK transaction.
// type Tx struct {
//     // Implementation of the transaction details (e.g., messages, signatures)
// }

// Event defines a structure for an event.
type Event struct {
    Type       string            `json:"type"`       // Event type
    Attributes []EventAttribute  `json:"attributes"` // Event attributes
}
type Response struct {
	Limit int `json:"limit"`
	Txs   []Tx `json:"txs"`
}

type Tx struct {
	ID        int       `json:"id"`
	Tx        TxDetails `json:"tx"`
	Logs      ABCIMessageLogs     `json:"logs"`
	Height    string    `json:"height"`
	Txhash    string    `json:"txhash"`
	RawLog    string    `json:"raw_log"`
	GasUsed   string    `json:"gas_used"`
	Timestamp time.Time `json:"timestamp"`
	GasWanted string    `json:"gas_wanted"`
}

type TxDetails struct {
	Type  string `json:"type"`
	Value Value  `json:"value"`
}
type Value struct {
	Fee           Fee         `json:"fee"`
	Msg           []Msg       `json:"msg"`
	Memo          string      `json:"memo"`
	Signatures    []Signature `json:"signatures"`
	TimeoutHeight string      `json:"timeout_height"`
}
type Fee struct {
	Gas    string  `json:"gas"`
	Amount []Amount `json:"amount"`
}

type Amount struct {
	Denom  string `json:"denom"`
	Amount string `json:"amount"`
}
type Msg struct {
	Type  string `json:"type"`
	Value MsgValue `json:"value"`
}
type MsgValue struct {
	Msg      map[string]interface{} `json:"msg"`
	Funds    []interface{} `json:"funds"`
	Sender   string      `json:"sender"`
	Contract string      `json:"contract"`
}
type ABCIMessageLogx struct {
	MsgIndex uint32        `json:"msg_index"`
	Events   []StringEvent `json:"events"`
}

type TxResponseLog struct {
	ABCIMessageLogs []ABCIMessageLogx `json:"abcimessage_logs"`
}

type TxRequest struct {
    TxBytes string `json:"tx_bytes"`
    Mode    string `json:"mode"`
}
type SubmitBlob struct {
    Contents Contents `json:"contents"`
}

type Contents struct {
    Action  string `json:"action"`
    BlobID  int    `json:"blob_id"`
    Message string `json:"message"`
 }
// type ClaimReward struct {
// 	LockType int `json:"lock_type"`
// }
type SubmitReq struct {
    SubmitBlob SubmitBlob `json:"submit_blob"`
}
type PubKey struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}
type Signature struct {
	PubKey    PubKey `json:"pub_key"`
	Signature string `json:"signature"`
}
func NewTerraClassicTX(clientCtx clientx.Context,sequence uint64,accountNumber uint64, configtx Config,ctx context.Context,encodedBlob string,blobID int, feeAmount uint64, gasLimit uint64)( SubmitResponse, error){
	fmt.Println("Sequencia -----------------------------: ", sequence)
	fmt.Println("accountNumber -----------------------------: ", accountNumber)
	
	
	chainID         := configtx.AppID
	denom           := "uluna"
	privateKeyHex   := configtx.PrivateKeyHex // Chave privada em formato hexadecimal
	fromAddress     := configtx.FromAddress           // Endereço do remetente
	contractAddress := configtx.ContractAddress         // Endereço do contrato inteligent

	var executeMsg SubmitReq

    // Atribuição de valores aos campos da estrutura
    executeMsg.SubmitBlob.Contents.Action = "submit"
    executeMsg.SubmitBlob.Contents.BlobID = blobID
    executeMsg.SubmitBlob.Contents.Message = encodedBlob

	executeMsgBytes, err := json.Marshal(executeMsg)
	if err != nil {
		fmt.Println("failed to marshal execute message: ", err)
	}

	msg := wasmtypes.MsgExecuteContract{
		Sender:   fromAddress,
		Contract: contractAddress,
		Msg:      executeMsgBytes,
		Funds:    sdktypes.Coins{}, // Corrigido para o tipo sdk.Coins
	}


    // Carregar configurações de transações
    marshaler := codec.NewProtoCodec(clientCtx.InterfaceRegistry)
	
    txConfig := authtx.NewTxConfig(marshaler, authtx.DefaultSignModes)

    clientCtx = clientCtx.WithTxConfig(txConfig)
	txBuilder:= clientCtx.TxConfig.NewTxBuilder()
	
	err = txBuilder.SetMsgs(&msg)
    if err != nil {
		fmt.Println("Failed to create message: ", err)
    }

	txBuilder.SetGasLimit(uint64(gasLimit)) // Set the gas limit
    txBuilder.SetFeeAmount(sdktypes.NewCoins(sdktypes.NewInt64Coin(denom, int64(feeAmount)  ) )) 
    txBuilder.SetMemo("")
    txBuilder.SetTimeoutHeight(0)
	

	privKeyBytes, err := hex.DecodeString(privateKeyHex)
	if err != nil {
		fmt.Println("failed to decode private key: ", err)
	}

	privKey := secp256k1.PrivKey{Key: privKeyBytes}
	pubKey := privKey.PubKey()

	var sigsV2 []signing.SignatureV2
	sigV2 := signing.SignatureV2{
		PubKey: pubKey,
		Data: &signing.SingleSignatureData{
			SignMode:  signing.SignMode(clientCtx.TxConfig.SignModeHandler().DefaultMode()),
			Signature: nil,
		},
		Sequence:  sequence,
	}
	sigsV2 = append(sigsV2,sigV2)
	err = txBuilder.SetSignatures(sigsV2...)
    if err != nil {
		fmt.Println("Erro na assinatura: ", err)
    }

	
	sigsV2 = []signing.SignatureV2{}
	var signerData = xauthsigning.SignerData{
		ChainID:       chainID,
		AccountNumber: accountNumber,
		Sequence:      sequence,
	}
	
	
	sigV2, err =  tx.SignWithPrivKey(
		signing.SignMode(clientCtx.TxConfig.SignModeHandler().DefaultMode()), signerData,
		txBuilder,&privKey, clientCtx.TxConfig, sequence)
	if err != nil {
		fmt.Println("Erro na assinatura: ", err)
	}

	sigsV2 = append(sigsV2, sigV2)
	err = txBuilder.SetSignatures(sigsV2...)
    if err != nil {
        fmt.Println("erro na assinatura : ", err)
    }




	
	// // Generated Protobuf-encoded bytes.
    txBytes, err := clientCtx.TxConfig.TxEncoder()(txBuilder.GetTx())
    if err != nil {
		fmt.Println(".GetTx: ", err)
    }
 	fmt.Printf("Transaction broadcast response TX: %v\n", string(txBytes))
//     //Generate a JSON string.
    // txJSONBytes, err := clientCtx.TxConfig.TxJSONEncoder()(txBuilder.GetTx())
    // if err != nil {
    //     fmt.Println("TxJSONEncoder .GetTx: ", err)
    // }
// 	fmt.Printf("Transaction broadcast response TX JSON: %v\n", string(txJSONBytes))


// Codifique a transação assinada em JSON
	txJSON, err := json.Marshal(map[string]interface{}{
		
		"mode": "BROADCAST_MODE_BLOCK", // Você pode usar "sync" ou "async" também
		"tx_bytes":  txBytes,
	})
	if err != nil {
		fmt.Println(" tx BROADCAST_MODE_BLOCK : ", err)
	}

	// Envie a transação para a blockchain
	resp, err := http.Post("http://localhost:1317/cosmos/tx/v1beta1/txs", "application/json", bytes.NewReader(txJSON))
	if err != nil {
		fmt.Println("http://localhost:1317/txs : ", err)
	}
	defer func() {
		err = resp.Body.Close()
		if err != nil {
			fmt.Println("error closing response body", err)
		}
	}()


	// // Leia a resposta da transação
	// var result map[string]interface{}
	// json.NewDecoder(resp.Body).Decode(&result)

responseData, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("erro na Body - Post: ", err)
	}
	//fmt.Println("sucesso",string(responseData))
	
	var submitrequest SubmitResponse
    
	//requestBodyx, err := json.Marshal(grpcRes)
	//log.Println("Dados pppp: ", string(requestBodyx))
    //var logs []ABCIMessageLog
	// var txResponseLog TxResponseLog
	// err = json.Unmarshal([]byte(responseData.TxResponse.RawLog), &logs)
	// if err != nil {
	// 	//fmt.Println("Error parsing TxResponseLog:", err)
	// 	fmt.Println("RawLog TxResponseLog:", string(grpcRes.TxResponse.RawLog))
	// 	//log.Println("RawLog TxResponseLog log: ", string(requestBodyx))
	// 	return submitrequest,err
	// }
	if(!strings.Contains(string(responseData), "terra_block_number")){
		//"account sequence mismatch
		fmt.Println("account sequence mismatch",string(responseData))
		//fmt.Println(" 333333 erro  - TxResponse:",string(responseData))
		return submitrequest,fmt.Errorf("account sequence mismatch")
	}
	var txResponseTerra ResponseTerra
	err = json.Unmarshal(responseData, &txResponseTerra)
	if err != nil {
		//fmt.Println(" 0000 - TxResponse:",err)
		fmt.Println("Error parsing TxResponse:","account sequence mismatch")
		return submitrequest,fmt.Errorf("account sequence mismatch")
	}
	// TxResponseLogBytes, err := json.Marshal(txResponse.RawLog)
	// if err != nil {
	// 	log.Fatalf("failed to marshal TxResponseLogBytes message: %v", err)
	// }
	
	terra_block_number := findAttributeByKeyName(txResponseTerra.TxResponse.Logs, "terra_block_number")
	// if terra_block_number != nil {
	// 	fmt.Printf("Valor da chave '%s': %s\n", "terra_block_number", terra_block_number.Value)
	// } else {
	// 	fmt.Printf("Chave '%s' não encontrada\n", "terra_block_number")
	// }
	numBlockNumber, err := strconv.ParseUint(terra_block_number.Value, 10, 32)
    if err != nil {
        fmt.Println("Erro ao converter string para uint32:", err)
		return submitrequest,err
       
    }
	
	terra_blob_count := findAttributeByKeyName(txResponseTerra.TxResponse.Logs, "blob_count")
	// if terra_blob_count != nil {
	// 	fmt.Printf("Valor da chave '%s': %s\n", "terra_block_number", terra_blob_count.Value)
	// } else {
	// 	fmt.Printf("Chave '%s' não encontrada\n", "terra_blob_count")
	// }
	numblob_count, err := strconv.ParseUint(terra_blob_count.Value, 10, 32)
    if err != nil {
        fmt.Println("Erro ao converter string para uint32:", err)
		return submitrequest,err
       
    }


    
	
	submitrequest.BlockHash = txResponseTerra.TxResponse.Data
	submitrequest.TransactionHash =txResponseTerra.TxResponse.TxHash
	submitrequest.BlockNumber =uint32(numBlockNumber)
	submitrequest.TransactionIndex = uint32(numblob_count)
	
	// submitrequestBytes, err := json.Marshal(submitrequest)
	// if err != nil {
	// 	fmt.Println("erro na submitrequestBytes:", err)
	// }

	//fmt.Println(string(submitrequestBytes))
	return submitrequest,nil
}
// Função personalizada para encontrar um EventAttribute com uma chave específica
func findAttributeByKeyName(logs []ABCIMessageLog, keyName string) *EventAttribute {
	for _, msgLog := range logs {
		for _, event := range msgLog.Events {
			for _, attr := range event.Attributes {
				if attr.Key == keyName {
					return &attr
				}
			}
		}
	}
	return nil // Retorna nil se não encontrar
}
func GetBlock(block uint32,configtx Config) ([]string, error){
	var DataBlob []string
   data,_,err:=	SearchBlob(block ,configtx, 0)
   if err != nil {
	return nil,err
   }
   for _, dataItem := range data {
	  DataBlob = append(DataBlob, dataItem)
	}
	// for limit > 0 {
	// 	datax,limitx,err:=SearchBlob(block ,configtx, limit)
	// 	limit = limitx
	// 	if err != nil {
	// 	 return nil,err
	// 	}
	// 	for _, dataItemx := range datax {
	// 	   DataBlob = append(DataBlob, dataItemx)
	// 	 }
       
       
    // }
	return DataBlob,nil
}
func SearchBlob(block uint32,configtx Config, limit int) ([]string,int, error){
	var DataBlob []string
	useLimit := ""
	// if(limit>0){
	// 	useLimit = "&limit="+fmt.Sprint(limit)
	// }
	blocksURL := configtx.FcdURL+"/v1/txs?block="+fmt.Sprint(block)+useLimit
	parsedURL, err := url.Parse(blocksURL)
	if err != nil {
		//log.Println("error 1", err)
		return nil,0,err

	}
	req, err := http.NewRequest("GET", parsedURL.String(), nil)
	//log.Println("URL ", parsedURL.String())
	if err != nil {
		//log.Println("error 2", err)
		return nil,0,err
	}
	client := http.DefaultClient
	response, err := client.Do(req)
	if err != nil {
		//log.Println("error 3", err)
		return nil,0,err
	}
	defer func() {
		err = response.Body.Close()
		if err != nil {
			log.Println("error closing response body", err)
			
		}
	}()
	responseData, err := io.ReadAll(response.Body)
	if err != nil {
		//log.Println("error 3", err)
		return nil,0,err
	}
	var blocksObject Response
	if string(responseData) == BLOCK_NOT_FOUND {
		log.Println("sucesso BLOCK_NOT_FOUND")
		blocksObject = Response{Txs: []Tx{}}
	} else if string(responseData) == PROCESSING_BLOCK {
		log.Println("sucesso PROCESSING_BLOCK")
		time.Sleep(10 * time.Second)
		//goto Loop
	} else {
		err = json.Unmarshal(responseData, &blocksObject)
		if err != nil {
			//log.Println("error 4", err)
			return nil,0,err
		}
	}
	
	
	for _, dataTx := range blocksObject.Txs {
		for _,msgTx := range dataTx.Tx.Value.Msg {
			 if(msgTx.Value.Contract ==configtx.ContractAddress)  {
				parsedMsg, err := parseMsg(msgTx.Value.Msg)
				if err != nil {
					fmt.Println("Error parsing msg:", err)
					
					return nil,0,err
				}
				switch vData := parsedMsg.(type) {
				case SubmitBlob:
					DataBlob = append(DataBlob,vData.Contents.Message)
					
				// case ClaimReward:
				// 	fmt.Printf("Parsed ClaimReward: %+v\n", v)
				default:
					fmt.Println("Unknown message type")
				}
			 } 
		}
	}
	
	
	return DataBlob,blocksObject.Limit,nil
}